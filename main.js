/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// EventManager.ts
var EventManager_exports = {};
__export(EventManager_exports, {
  EventManager: () => EventManager
});
var import_obsidian4, EventManager;
var init_EventManager = __esm({
  "EventManager.ts"() {
    import_obsidian4 = require("obsidian");
    EventManager = class {
      constructor(app, filePath) {
        this.events = {};
        this.app = app;
        this.filePath = filePath;
      }
      async loadEvents() {
        try {
          const file = this.app.vault.getAbstractFileByPath(this.filePath);
          if (file instanceof import_obsidian4.TFile) {
            const content = await this.app.vault.read(file);
            this.events = JSON.parse(content);
          }
        } catch (error) {
          console.log("No existing events file, starting fresh");
          this.events = {};
        }
      }
      async saveEvents() {
        try {
          const content = JSON.stringify(this.events, null, 2);
          const file = this.app.vault.getAbstractFileByPath(this.filePath);
          if (file instanceof import_obsidian4.TFile) {
            await this.app.vault.modify(file, content);
          } else {
            await this.app.vault.create(this.filePath, content);
          }
        } catch (error) {
          console.error("Error saving events:", error);
        }
      }
      getEvents() {
        return this.events;
      }
      getEventsForDate(date) {
        const events = this.events[date];
        if (!events) return [];
        return Array.isArray(events) ? events : [events];
      }
      async addEvent(date, event) {
        let events = this.events[date];
        if (!events) {
          events = [];
        } else if (!Array.isArray(events)) {
          events = [events];
        }
        events.push(event);
        this.events[date] = events;
        await this.saveEvents();
      }
      async updateEvent(date, eventIndex, event) {
        let events = this.getEventsForDate(date);
        if (eventIndex >= 0 && eventIndex < events.length) {
          events[eventIndex] = event;
          this.events[date] = events;
          await this.saveEvents();
        }
      }
      async deleteEvent(date, eventIndex) {
        let events = this.getEventsForDate(date);
        events.splice(eventIndex, 1);
        if (events.length === 0) {
          delete this.events[date];
        } else {
          this.events[date] = events;
        }
        await this.saveEvents();
      }
      async deleteAllEventsForDate(date) {
        delete this.events[date];
        await this.saveEvents();
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CalendarEventPlannerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// CalendarView.ts
var import_obsidian3 = require("obsidian");

// CalendarRenderer.ts
var CalendarRenderer = class {
  constructor(container, eventManager, openEventModal, openEventListModal) {
    this.currentView = "full";
    this.today = /* @__PURE__ */ new Date();
    this.todayStr = this.today.toISOString().split("T")[0];
    this.year = this.today.getFullYear();
    this.currentMonth = this.today.getMonth();
    this.quarter = Math.ceil((this.currentMonth + 1) / 3);
    this.themes = {
      1: { title: "Q1 - Winter/Spring Reset", subtitle: "January \u2013 March" },
      2: { title: "Q2 - Summer Surge", subtitle: "April \u2013 June" },
      3: { title: "Q3 - Monsoon Momentum", subtitle: "July \u2013 September" },
      4: { title: "Q4 - Winter Lock-In", subtitle: "October \u2013 December" }
    };
    this.months = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    this.container = container;
    this.eventManager = eventManager;
    this.openEventModalCallback = openEventModal;
    this.openEventListModalCallback = openEventListModal;
  }
  render() {
    this.container.empty();
    const root = this.container.createDiv({ cls: "cal-container" });
    this.createHeader(root);
    this.gridContainer = root.createDiv({ cls: "cal-grid" });
    this.renderCalendar();
  }
  refresh() {
    this.renderCalendar();
  }
  createHeader(root) {
    const header = root.createDiv({ cls: "cal-header" });
    const theme = this.themes[this.quarter];
    header.createDiv({ cls: "cal-title", text: theme.title });
    const dateOptions = {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric"
    };
    const formattedDate = this.today.toLocaleDateString("en-US", dateOptions);
    header.createDiv({ cls: "cal-sub", text: formattedDate });
    this.createToggleSwitch(header);
  }
  createToggleSwitch(header) {
    const toggleContainer = header.createDiv({ cls: "cal-toggle-container" });
    const toggleSwitch = toggleContainer.createDiv({ cls: "cal-toggle-switch" });
    const toggleKnob = toggleSwitch.createDiv({ cls: "cal-toggle-knob" });
    toggleSwitch.createSpan({ cls: "cal-toggle-label cal-toggle-year", text: "Year" });
    toggleSwitch.createSpan({ cls: "cal-toggle-label cal-toggle-month", text: "Month" });
    toggleSwitch.createSpan({ cls: "cal-toggle-label cal-toggle-week", text: "Week" });
    let toggleState = 0;
    toggleSwitch.addEventListener("click", () => {
      toggleState = (toggleState + 1) % 3;
      toggleSwitch.removeClass("state-0", "state-1", "state-2");
      toggleSwitch.addClass(`state-${toggleState}`);
      if (toggleState === 0) {
        this.currentView = "full";
      } else if (toggleState === 1) {
        this.currentView = "month";
      } else {
        this.currentView = "week";
      }
      this.renderCalendar();
    });
  }
  renderCalendar() {
    this.gridContainer.empty();
    let monthsToShow = [];
    if (this.currentView === "full") {
      monthsToShow = Array.from({ length: 12 }, (_, i) => i);
    } else {
      monthsToShow = [this.currentMonth];
    }
    monthsToShow.forEach((mi) => {
      this.renderMonth(mi);
    });
    setTimeout(() => this.applyEventBorders(), 100);
  }
  renderMonth(monthIndex) {
    const box = this.gridContainer.createDiv({ cls: "cal-month" });
    box.createEl("h3", { text: this.months[monthIndex] });
    const cal = box.createDiv({ cls: "cal-calendar" });
    ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"].forEach((d) => {
      const wd = cal.createDiv({ cls: "cal-wd" });
      if (d === "Sun") wd.addClass("sunday");
      wd.setText(d);
    });
    const { startDay, endDay } = this.calculateDaysToShow(monthIndex);
    const firstDayOfMonth = this.getFirstDay(this.year, monthIndex);
    for (let i = 0; i < firstDayOfMonth; i++) {
      cal.createDiv({ cls: "cal-day cal-empty" });
    }
    for (let d = startDay; d <= endDay; d++) {
      const date = this.formatDate(this.year, monthIndex, d);
      const cell = cal.createDiv({ cls: "cal-day", text: d.toString() });
      cell.dataset.date = date;
      if (date === this.todayStr) {
        cell.addClass("today");
      }
      cell.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        this.showContextMenu(e, date);
      });
      this.addTooltip(cell, date);
    }
  }
  calculateDaysToShow(monthIndex) {
    const totalDays = this.getDaysInMonth(this.year, monthIndex);
    if (this.currentView === "week") {
      const todayDayOfWeek = this.today.getDay();
      const mondayOffset = todayDayOfWeek === 0 ? -6 : 1 - todayDayOfWeek;
      const startDay = Math.max(1, this.today.getDate() + mondayOffset);
      const endDay = Math.min(totalDays, startDay + 6);
      return { startDay, endDay };
    }
    return { startDay: 1, endDay: totalDays };
  }
  showContextMenu(event, date) {
    const existing = document.querySelector(".cal-context-menu");
    if (existing) existing.remove();
    const menu = document.body.createDiv({ cls: "cal-context-menu" });
    menu.style.left = event.pageX + "px";
    menu.style.top = event.pageY + "px";
    const addEvent = menu.createDiv({ cls: "cal-context-item", text: "Add Event" });
    addEvent.addEventListener("click", () => {
      this.openEventModalCallback(date, null);
      menu.remove();
    });
    const listEvents = menu.createDiv({ cls: "cal-context-item", text: "List Scheduled Events" });
    listEvents.addEventListener("click", () => {
      this.openEventListModalCallback(date);
      menu.remove();
    });
    const closeMenu = () => {
      menu.remove();
      document.removeEventListener("click", closeMenu);
    };
    setTimeout(() => document.addEventListener("click", closeMenu), 0);
  }
  addTooltip(cell, date) {
    const tooltip = document.body.createDiv({ cls: "cal-tooltip" });
    tooltip.style.display = "none";
    cell.addEventListener("mouseenter", (e) => {
      const events = this.eventManager.getEventsForDate(date);
      if (events.length === 0) return;
      tooltip.empty();
      tooltip.createDiv({ cls: "cal-tooltip-date", text: date });
      events.forEach((evt) => {
        const eventDiv = tooltip.createDiv({ cls: "cal-tooltip-event" });
        eventDiv.style.borderLeftColor = evt.color;
        if (evt.time) {
          eventDiv.createDiv({ cls: "cal-tooltip-time", text: evt.time });
        }
        eventDiv.createDiv({ cls: "cal-tooltip-title", text: evt.title || "Untitled Event" });
        if (evt.desc) {
          eventDiv.createDiv({ cls: "cal-tooltip-desc", text: evt.desc });
        }
      });
      tooltip.createDiv({
        cls: "cal-tooltip-count",
        text: `${events.length} event${events.length === 1 ? "" : "s"}`
      });
      tooltip.style.display = "block";
      tooltip.style.left = e.pageX + 10 + "px";
      tooltip.style.top = e.pageY + 10 + "px";
    });
    cell.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
    });
    cell.addEventListener("mousemove", (e) => {
      if (tooltip.style.display === "block") {
        tooltip.style.left = e.pageX + 10 + "px";
        tooltip.style.top = e.pageY + 10 + "px";
      }
    });
  }
  applyEventBorders() {
    const events = this.eventManager.getEvents();
    Object.entries(events).forEach(([date, eventData]) => {
      const cell = this.container.querySelector(`[data-date="${date}"]`);
      if (!cell) return;
      cell.style.boxShadow = "";
      const eventArray = Array.isArray(eventData) ? eventData : [eventData];
      const colors = eventArray.map((evt) => evt == null ? void 0 : evt.color).filter(Boolean);
      if (colors.length === 0) return;
      const shadows = colors.reverse().map((color, i) => {
        const width = 2 + i * 2;
        return `inset 0 0 0 ${width}px ${color}`;
      }).join(", ");
      cell.style.boxShadow = shadows;
    });
  }
  getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
  }
  getFirstDay(year, month) {
    const day = new Date(year, month, 1).getDay();
    return day === 0 ? 6 : day - 1;
  }
  formatDate(year, month, day) {
    return `${year}-${String(month + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
  }
};

// EventModal.ts
var import_obsidian = require("obsidian");
var EventModal = class extends import_obsidian.Modal {
  constructor(app, eventManager, date, eventIndex, onSave) {
    super(app);
    this.eventManager = eventManager;
    this.date = date;
    this.eventIndex = eventIndex;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("calendar-event-modal");
    contentEl.createEl("h2", {
      text: this.eventIndex !== null ? "Edit Event" : "Add Event"
    });
    let existingEvent = null;
    if (this.eventIndex !== null) {
      const events = this.eventManager.getEventsForDate(this.date);
      existingEvent = events[this.eventIndex] || null;
    }
    new import_obsidian.Setting(contentEl).setName("Date").addText((text) => {
      text.setValue(this.date);
      text.setDisabled(true);
    });
    new import_obsidian.Setting(contentEl).setName("Time").addText((text) => {
      this.timeInput = text.inputEl;
      this.timeInput.type = "time";
      this.timeInput.value = (existingEvent == null ? void 0 : existingEvent.time) || "";
    });
    new import_obsidian.Setting(contentEl).setName("Title").addText((text) => {
      this.titleInput = text.inputEl;
      this.titleInput.placeholder = "Event title";
      this.titleInput.value = (existingEvent == null ? void 0 : existingEvent.title) || "";
      this.titleInput.style.width = "100%";
    });
    new import_obsidian.Setting(contentEl).setName("Description").setDesc("Optional event description").addTextArea((text) => {
      this.descInput = text.inputEl;
      this.descInput.rows = 3;
      this.descInput.value = (existingEvent == null ? void 0 : existingEvent.desc) || "";
      this.descInput.style.width = "100%";
    });
    const colorSetting = new import_obsidian.Setting(contentEl).setName("Border Color").setDesc("Choose event border color");
    this.colorInput = colorSetting.controlEl.createEl("input", {
      type: "color",
      value: (existingEvent == null ? void 0 : existingEvent.color) || "#1CA08F"
    });
    this.colorInput.style.width = "60px";
    this.colorInput.style.height = "30px";
    this.colorInput.style.cursor = "pointer";
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    if (this.eventIndex !== null) {
      const deleteBtn = buttonContainer.createEl("button", {
        text: "Delete",
        cls: "mod-warning"
      });
      deleteBtn.addEventListener("click", () => this.handleDelete());
    }
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", {
      text: "Save",
      cls: "mod-cta"
    });
    saveBtn.addEventListener("click", () => this.handleSave());
  }
  async handleSave() {
    const event = {
      time: this.timeInput.value,
      title: this.titleInput.value,
      desc: this.descInput.value,
      color: this.colorInput.value
    };
    if (!event.title && !event.desc) {
      this.close();
      return;
    }
    if (this.eventIndex !== null) {
      await this.eventManager.updateEvent(this.date, this.eventIndex, event);
    } else {
      await this.eventManager.addEvent(this.date, event);
    }
    this.onSave();
    this.close();
  }
  async handleDelete() {
    if (this.eventIndex !== null) {
      await this.eventManager.deleteEvent(this.date, this.eventIndex);
      this.onSave();
      this.close();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// EventListModal.ts
var import_obsidian2 = require("obsidian");
var EventListModal = class extends import_obsidian2.Modal {
  constructor(app, eventManager, date, onEdit, onUpdate) {
    super(app);
    this.eventManager = eventManager;
    this.date = date;
    this.onEdit = onEdit;
    this.onUpdate = onUpdate;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("calendar-event-list-modal");
    contentEl.createEl("h2", { text: `Events for ${this.date}` });
    const events = this.eventManager.getEventsForDate(this.date);
    if (events.length === 0) {
      contentEl.createDiv({
        cls: "calendar-no-events",
        text: "No events scheduled"
      });
    } else {
      const listContainer = contentEl.createDiv({ cls: "calendar-event-list" });
      events.forEach((event, index) => {
        this.renderEventItem(listContainer, event, index);
      });
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const closeBtn = buttonContainer.createEl("button", { text: "Close" });
    closeBtn.addEventListener("click", () => this.close());
  }
  renderEventItem(container, event, index) {
    const eventItem = container.createDiv({ cls: "calendar-event-item" });
    const colorBar = eventItem.createDiv({ cls: "calendar-event-color-bar" });
    colorBar.style.backgroundColor = event.color;
    const eventContent = eventItem.createDiv({ cls: "calendar-event-content" });
    if (event.time) {
      eventContent.createDiv({ cls: "calendar-event-time", text: event.time });
    }
    eventContent.createDiv({
      cls: "calendar-event-title",
      text: event.title || "Untitled Event"
    });
    if (event.desc) {
      eventContent.createDiv({ cls: "calendar-event-desc", text: event.desc });
    }
    eventContent.addEventListener("click", () => {
      this.close();
      this.onEdit(index);
    });
    const deleteBtn = eventItem.createEl("button", {
      cls: "calendar-event-delete",
      text: "Delete"
    });
    deleteBtn.addEventListener("click", async (e) => {
      e.stopPropagation();
      await this.handleDelete(index);
    });
  }
  async handleDelete(eventIndex) {
    await this.eventManager.deleteEvent(this.date, eventIndex);
    this.onUpdate();
    this.onOpen();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// CalendarView.ts
var VIEW_TYPE_CALENDAR = "calendar-event-planner";
var CalendarView = class extends import_obsidian3.ItemView {
  constructor(leaf, eventManager) {
    super(leaf);
    this.eventManager = eventManager;
  }
  getViewType() {
    return VIEW_TYPE_CALENDAR;
  }
  getDisplayText() {
    return "Calendar";
  }
  getIcon() {
    return "calendar";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("calendar-view-container");
    await this.eventManager.loadEvents();
    this.renderer = new CalendarRenderer(
      container,
      this.eventManager,
      this.openEventModal.bind(this),
      this.openEventListModal.bind(this)
    );
    this.renderer.render();
  }
  async onClose() {
  }
  openEventModal(date, eventIndex = null) {
    new EventModal(
      this.app,
      this.eventManager,
      date,
      eventIndex,
      () => this.renderer.refresh()
    ).open();
  }
  openEventListModal(date) {
    new EventListModal(
      this.app,
      this.eventManager,
      date,
      (eventIndex) => this.openEventModal(date, eventIndex),
      () => this.renderer.refresh()
    ).open();
  }
};

// settings.ts
var import_obsidian5 = require("obsidian");
var CalendarSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Calendar Event Planner Settings" });
    new import_obsidian5.Setting(containerEl).setName("Event file path").setDesc("Path to the JSON file where events will be stored (relative to vault root)").addText((text) => text.setPlaceholder("calendar-events.json").setValue(this.plugin.settings.eventFilePath).onChange(async (value) => {
      this.plugin.settings.eventFilePath = value || "calendar-events.json";
      await this.plugin.saveSettings();
      this.plugin.eventManager = new (await Promise.resolve().then(() => (init_EventManager(), EventManager_exports))).EventManager(
        this.app,
        this.plugin.settings.eventFilePath
      );
    }));
    new import_obsidian5.Setting(containerEl).setName("About").setDesc("Calendar Event Planner v1.0.0 - A comprehensive calendar with event planning capabilities");
  }
};

// main.ts
init_EventManager();
var DEFAULT_SETTINGS = {
  eventFilePath: "calendar-events.json"
};
var CalendarEventPlannerPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.eventManager = new EventManager(this.app, this.settings.eventFilePath);
    this.registerView(
      VIEW_TYPE_CALENDAR,
      (leaf) => new CalendarView(leaf, this.eventManager)
    );
    this.addRibbonIcon("calendar", "Open Calendar", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-calendar",
      name: "Open Calendar",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new CalendarSettingTab(this.app, this));
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CALENDAR);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf("tab");
      await leaf.setViewState({
        type: VIEW_TYPE_CALENDAR,
        active: true
      });
    }
    workspace.revealLeaf(leaf);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
  }
};
